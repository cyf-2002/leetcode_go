## 有效的字母异位词

> 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
>
> 示例 1: 输入: s = "anagram", t = "nagaram" 输出: true
>
> 示例 2: 输入: s = "rat", t = "car" 输出: false
>
> **说明:** 你可以假设字符串只包含小写字母。

```go
func isAnagram(s string, t string) bool {
	m := [26]int{}
	for _, ch := range s {
		m[ch-'a'] += 1
	}
	for _, ch := range t {
		m[ch-'a'] -= 1
	}
	return m == [26]int{}
}
```

---

## 两个数组的交集

> 题意：给定两个数组，编写一个函数来计算它们的交集。
>
> <img src="assets/20200818193523911.png" alt="349. 两个数组的交集" style="zoom: 50%;float: left" />

`map[int]struct{}`创建了一个键类型为`int`，值类型为空结构体的映射。使用空结构体作为映射的值类型的一个常见用途是实现集合的功能，因为映射的键是唯一的，而值在这种情况下并不重要。通过使用空结构体，可以节省内存，因为不需要为每个键存储一个实际的值，只需要存储键本身。

直接使用`set[num2]`与`struct{}{}`进行比较是不正确的。要检查一个键是否存在于映射中，我们应该使用逗号ok的形式，如`value, ok := set[key]`

```go
func intersection(nums1 []int, nums2 []int) []int {
	set := make(map[int]struct{}, 0)
	res := make([]int, 0)
	for _, num1 := range nums1 {
		if _, ok := set[num1]; !ok {
			set[num1] = struct{}{}
		}
	}
	for _, num2 := range nums2 {
		if _, ok := set[num2]; ok {
			res = append(res, num2)
			delete(set, num2)
		}
	}
	return res
}
```

---

## 快乐数

> 编写一个算法来判断一个数 n 是不是快乐数。
>
> 「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。
>
> 如果 n 是快乐数就返回 True ；不是，则返回 False 。
>
> **示例：**
>
> 输入：19
> 输出：true
> 解释：
> 1^2 + 9^2 = 82
> 8^2 + 2^2 = 68
> 6^2 + 8^2 = 100
> 1^2 + 0^2 + 0^2 = 1

简单的哈希即可，set的模拟不是很熟练，`value, ok := set[key]`

```go
func isHappy(n int) bool {
	set := make(map[int]struct{}, 0)
	sum := squrSum(n)
	for sum != 1 {
		if _, ok := set[sum]; ok{
			return false
		} else {
			set[sum] = struct{}{}
			sum = squrSum(sum)
		}
	}
	return true
}

func squrSum(n int) int {
	res := 0
	for n != 0 {
		res += (n % 10) * (n % 10)
		n /= 10
	}
	return res
}
```

---

## 两数之和

> 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
>
> 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。
>
> **示例:**
>
> 给定 nums = [2, 7, 11, 15], target = 9
>
> 因为 nums[0] + nums[1] = 2 + 7 = 9
>
> 所以返回 [0, 1]

最初的思考是遍历两次，但是要考虑到可能会存在`6 = 3 + 3`的情况，两个相同的元素并不能存储在map中，因此可以考虑**在遍历的时候，直接去搜索`set[target - val]`**是否存在

```go
func twoSum(nums []int, target int) []int {
	set := make(map[int]int, 0)
	for i, val := range nums {
		if v, ok := set[target - val]; ok {
			return []int{v, i}
		} else {
			set[val] = i
		}
	}
	return []int{}
}
```

---

## 四数相加II

> 给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。
>
> 为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。
>
> **例如:**
>
> 输入:
>
> - A = [ 1, 2]
> - B = [-2,-1]
> - C = [-1, 2]
> - D = [ 0, 2]
>
> 输出:
>
> 2
>
> **解释:**
>
> 两个元组如下:
>
> 1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
> 2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0

一个`set`存储`a + b`，另一个存储`c + d`，将`O(n^4)`分解为`O(n^2) + O(n^2)`

```go
func fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int {
	set1 := make(map[int]int, 0)
	res := 0
	for _, val1 := range nums1 {
		for _, val2 := range nums2 {
			set1[val1+val2] += 1
		}
	}
	for _, val3 := range nums3 {
		for _, val4 := range nums4 {
			if count, ok := set1[0-val3-val4]; ok {
				res += count
			}
		}
	}
	return res
}
```

---

## 赎金信

> 给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。
>
> (题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)
>
> **注意：**
>
> 你可以假设两个字符串均只含有小写字母。
>
> canConstruct("a", "b") -> false
> canConstruct("aa", "ab") -> false
> canConstruct("aa", "aab") -> true

可以用`map`，但是由于只包含小写字母，用数组更快一点

```go
func canConstruct(ransomNote string, magazine string) bool {
	record := make([]int, 26)
	for _, v := range magazine {
		record[v-'a']++
	}
	for _, v := range ransomNote {
		record[v-'a']--
		if record[v-'a'] < 0 {
			return false
		}
	}
	return true
}
```

---

## 三数之和

> 



```go
```

---

## 四数之和

> 



```go
```

---

