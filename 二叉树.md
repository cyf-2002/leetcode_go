## 翻转二叉树

> 给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。<img src="assets/invert1-tree.jpg" alt="img" style="zoom:50%;" />

递归版本的前序遍历

```go
func invertTree(root *TreeNode) *TreeNode {
    if root == nil {
        return nil
    }
    root.Left, root.Right = root.Right, root.Left    //交换
    
    invertTree(root.Left)
    invertTree(root.Right)

    return root
}
```

层序遍历

```go
func invertTree(root *TreeNode) *TreeNode {
	if root == nil {
		return root
	}

	queue := []*TreeNode{root}
	for len(queue) > 0 {
		levelSize := len(queue)
		for i := 0; i < levelSize; i++ {
			queue[i].Left, queue[i].Right = queue[i].Right,queue[i].Left
			if queue[i].Left != nil {
				queue = append(queue, queue[i].Left)
			}
			if queue[i].Right != nil {
				queue = append(queue, queue[i].Right)
			}
		}

		queue = queue[levelSize:]
	}

	return root
}
```


---

## 对称二叉树

> 给定一个二叉树，检查它是否是镜像对称的。
>
> <img src="assets/20210203144607387.png" alt="101. 对称二叉树" style="zoom: 50%;" />

本题遍历只能是“后序遍历”，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。

**正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。**

单层递归的逻辑，单层递归的逻辑就是处理 左右节点都不为空，且数值相同的情况。

- 比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。
- 比较内侧是否对称，传入左节点的右孩子，右节点的左孩子。
- 如果左右都对称就返回true ，有一侧不对称就返回false 。

```go
func compare(left *TreeNode, right *TreeNode) bool {
    // 首先排除空节点的情况
	if left == nil && right == nil {
		return true
	} else if left == nil && right != nil {
		return false
	} else if left != nil && right == nil {
		return false
	} else if left.Val != right.Val {
		return false
	}
	// 左右节点都不为空，且数值相同的情况
	outside := compare(left.Left, right.Right)
	inside := compare(left.Right, right.Left)
	isSame := outside && inside

	return isSame
}

func isSymmetric(root *TreeNode) bool {
	if root == nil {
		return true
	}
	return compare(root.Left, root.Right)
}
```

---

## 平衡二叉树

> 给定一个二叉树，判断它是否是高度平衡的二叉树。
>
> 示例 1:
>
> 给定二叉树 [3,9,20,null,null,15,7]
>
> <img src="assets/2021020315542230.png" alt="110.平衡二叉树"  />
>
> 返回 true 。
>
> 示例 2:
>
> 给定二叉树 [1,2,2,3,3,null,null,4,4]
>
> ![110.平衡二叉树1](assets/20210203155447919.png)
>
> 返回 false 。

自底向上递归的做法类似于后序遍历，对于当前遍历到的节点，先递归地判断其左右子树是否平衡，再判断以当前节点为根的子树是否平衡。如果一棵子树是平衡的，则返回其高度（高度一定是非负整数），否则返回 −1 。如果存在一棵子树不平衡，则整个二叉树一定不平衡。

```go
func isBalanced(root *TreeNode) bool {
	h := getHeight(root)
	return h != -1
}

// 返回以该节点为根节点的二叉树的高度，如果不是平衡二叉树了则返回-1
func getHeight(root *TreeNode) int {
	if root == nil {
		return 0
	}
	l, r := getHeight(root.Left), getHeight(root.Right)
	if l == -1 || r == -1 {
		return -1
	}
	if abs(l-r) > 1 {
		return -1
	}
	return max(l, r) + 1
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

---

## 二叉树的所有路径

> 给定一个二叉树，返回所有从根节点到叶子节点的路径。
>
> 说明: 叶子节点是指没有子节点的节点。
>
> <img src="https://code-thinking-1253855093.file.myqcloud.com/pics/2021020415161576.png" alt="257.二叉树的所有路径1" style="zoom:80%;" />



```go
var res []string

func dfs(root *TreeNode, path string) {
	if root == nil {
		return
	}
	if root.Left == nil && root.Right == nil {
		res = append(res, path+strconv.Itoa(root.Val))
	}
	if root.Left != nil {
		dfs(root.Left, path+strconv.Itoa(root.Val)+"->")
	}
	if root.Right != nil {
		dfs(root.Right, path+strconv.Itoa(root.Val)+"->")
	}
}

func binaryTreePaths(root *TreeNode) []string {
	res = []string{}
	dfs(root, "")
	return res
}
```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

