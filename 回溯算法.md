## 模板

<img src="assets/20210130173631174.png" alt="回溯算法理论基础" style="zoom: 50%;" />

```go
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

---

## 组合问题

> 给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。
>
> n = 100，k = 50？？？

<img src="assets/20201123195242899.png" alt="77.组合1" style="zoom:50%;" />

```go
func combinationSum3(n int, k int) [][]int {
    path := make([]int, 0, k)
    res := make([][]int, 0)

    var backtracking func(n, k, start int)
    backtracking = func(n, k, start int) {
        if n == 0 && k == 0 {
            tmp := append([]int{}, path...) // 直接通过切片的方式完成拷贝
            res = append(res, tmp)
            return
        }

        for i := start; i <= 9; i++ {
            if i > n {
                break
            }
            if 9-i+1 < k-len(path) { // 剪枝
                break
            }
            path = append(path, i)
            backtracking(n-i, k-1, i+1)
            path = path[:len(path)-1] // 回溯
        }
    }

    backtracking(n, k, 1)
    return res
}
```

---

## 组合总和III

> 找出所有相加之和为 `n` 的 `k` 个数的组合，且满足下列条件：
>
> - 只使用数字1到9
> - 每个数字 **最多使用一次** 

```go
func combinationSum3(k int, n int) [][]int {
	path := make([]int, 0, k)
	res := make([][]int, 0)

	var backtracking func(n, k, start int)
	backtracking = func(n, k, start int) {
		if n == 0 && k == 0 {
			tmp := append([]int{}, path...)		//拷贝
			res = append(res, tmp)
			return
		}

		for i := start; i <= 9; i++ {
			if i > n {
				break
			}
			if 9-i+1 < k-len(path) {	//剪枝
				break
			}
			path = append(path, i)
			backtracking(n-i, k-1, i+1)
			path = path[:len(path)-1]	//回溯
		}
	}

	backtracking(n, k, 1)
	return res
}
```

---

## 电话号码的字母组合

> 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。
>
> <img src="assets/2020102916424043.png" alt="17.电话号码的字母组合" style="zoom:50%;" />

和组合问题类似，回溯时要知道应该读取 `digits` 的第几位，我刚开始只传递了一个 `[]byte` 参数，虽然也能解题， 但中间多了一些处理步骤，多传递一个 `start` 参数会方便许多。

```go
func letterCombinations(digits string) []string {
	letters := []string{"abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"}
	path := make([]byte, 0)
	res := make([]string, 0)
	if digits == "" {
		return res
	}

	var backtracking func(digits string, start int)	//用start参数来控制读取到哪个数字
	backtracking = func(digits string, start int) {
		if len(path) == len(digits) {
			tmp := string(path)
			res = append(res, tmp)
			return
		}

		str := letters[int(digits[start]-'0')-2]
		for i, _ := range str {
			path = append(path, str[i])
			backtracking(digits, start+1)
			path = path[:len(path)-1]
		}
	}

	backtracking(digits, 0)
	return res
}
```

---

## 组合总和II

> 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的每个数字在每个组合中只能使用一次。说明： 所有数字（包括目标数）都是正整数。解集不能包含重复的组合。
>
> **示例 2:**
>
> ```
> 输入: candidates = [2,5,2,1,2], target = 5,
> 输出:
> [
> [1,2,2],
> [5]
> ]
> ```

关键点：去重。阴差阳错的一次写对了，但是仔细分析去重的过程有点懵。

大概就是第一次遍历时全部取一遍。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20221021163812.png" alt="img" style="zoom: 40%;" />

```go
func combinationSum2(candidates []int, target int) [][]int {
	sort.Ints(candidates)
	path := make([]int, 0)
	res := make([][]int, 0)

	var backtracking func(target int, start int)
	backtracking = func(target int, start int) {
		if target == 0 {
			tmp := append([]int{}, path...)
			res = append(res, tmp)
			return
		}

		for i := start; i < len(candidates); i++ {
			if candidates[i] > target {	//剪枝	
				break
			}
			if i > start && candidates[i] == candidates[i-1] {	//去重
				continue
			}
			path = append(path, candidates[i])
			backtracking(target-candidates[i], i+1)
			path = path[:len(path)-1]
		}
	}

	backtracking(target, 0)
	return res
}
```

---

## 分割回文串

> 给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。
>
> 返回 s 所有可能的分割方案。
>
> 示例: 输入: "aab" 输出: [ ["aa","b"], ["a","a","b"] ]

两天一道题没写，写了一些小bug，头晕掉

```go
func partition(s string) [][]string {
	path := make([]string, 0)
	res := make([][]string, 0)

	var backtracking func(s string, start int)
	backtracking = func(s string, start int) {
		if start == len(s) {
			tmp := append([]string{}, path...)	//append，不是make
			res = append(res, tmp)
			return															//记得return
		}
		for i := start; i < len(s); i++ {
      if isPalindrome(s[start : i+1]) {		//s[0:0]返回的是空
				str := s[start : i+1]
				path = append(path, str)
				backtracking(s, i+1)
				path = path[:len(path)-1]
			}
		}
	}

	backtracking(s, 0)
	return res
}

func isPalindrome(s string) bool {
	for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
		if s[i] != s[j] {	//没必要用[]byte
			return false
		}
	}
	return true
}
```

---

## 复原IP地址

> 给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。
>
> 有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。
>
> 例如："0.1.2.201" 和 "192.168.1.1" 是 有效的 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效的 IP 地址。
>
> - 输入：s = "25525511135"
> - 输出：["255.255.11.135","255.255.111.35"]

- `make()`函数指定了size时，也应该指定len。

- 去除含有前导 '0' 的算法： `i != start && s[start] == '0'`

```go
func restoreIpAddresses(s string) []string {
	path := make([]string, 0, 4)
	res := make([]string, 0)

	var backtracking func(s string, start int)
	backtracking = func(s string, start int) {
		if len(path) == 4 {
			if start == len(s) {
				tmp := strings.Join(path, ".")
				res = append(res, tmp)
			}
			return
		}

		for i := start; i < len(s); i++ {
      //去除含有前导'0'
			if i != start && s[start] == '0' {
				break
			}
			str := s[start : i+1]
			num, _ := strconv.Atoi(str)
			if num >= 0 && num <= 255 {
				path = append(path, str)
				backtracking(s, i+1)
				path = path[:len(path)-1]
			} else {
				break
			}
		}
	}

	backtracking(s, 0)
	return res
}
```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

