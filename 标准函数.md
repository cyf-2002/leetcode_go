## func SearchInts(a []int, x int) int

返回 x 的下标，若 x 不存在，返回应该插入的 index。即返回第一个大于等于 x 的下标

```go
	a := []int{1, 2, 3, 4, 6, 7, 8}
	i = sort.SearchInts(a, 5)
	fmt.Printf("%d not found, can be inserted at index %d in %v\n", x, i, a)
	// 5 not found, can be inserted at index 4 in [1 2 3 4 6 7 8]
```

---

## func Replace(s, old, new string, n int) string

If n < 0, there is no limit on the number of replacements.  -> func ReplaceAll(s, old, new string) string

```go
	fmt.Println(strings.Replace("oink oink oink", "k", "ky", 2))
	// oinky oinky oink
```

---

## func Join(elems []string, sep string) string

create a single string. The separator string sep is placed between elements in the resulting string.

```go
	s := []string{"foo", "bar", "baz"}
	fmt.Println(strings.Join(s, ", "))
	// foo, bar, baz
```

---

## [treeset](https://pkg.go.dev/github.com/emirpasic/gods/sets/treeset)

```go
package main

import "github.com/emirpasic/gods/sets/treeset"

func main() {
	set := treeset.NewWithIntComparator() // empty (keys are of type int)
	set.Add(1)                            // 1
	set.Add(2, 2, 3, 4, 5)                // 1, 2, 3, 4, 5 (in order, duplicates ignored)
	set.Remove(4)                         // 1, 2, 3, 5 (in order)
	set.Remove(2, 3)                      // 1, 5 (in order)
	set.Contains(1)                       // true
	set.Contains(1, 5)                    // true
	set.Contains(1, 6)                    // false
	_ = set.Values()                      // []int{1,5} (in order)
	set.Clear()                           // empty
	set.Empty()                           // true
	set.Size()                            // 0
}
```

---

## slices

```go
	numbers := []int{0, 42, -10, 8}
	fmt.Println(slices.Equal(numbers, []int{0, 42, -10, 8}))	// true
	fmt.Println(slices.Max(numbers))	// 42
	slices.Sort(smallInts)	// [-10 0 8 42]
```

---

## pow(x, n)

谈一下**快速幂**的实现：77 = (1001101)~2~ 		x^77^ = x * x^4^ * x^8^ * x^64^

<img src="assets/image-20231210145227962.png" alt="image-20231210145227962" style="zoom:80%;" />

```go
func myPow(x float64, n int) float64 {
    if n >= 0 {
        return quickMul(x, n)
    }
    return 1.0 / quickMul(x, -n)
}

func quickMul(x float64, n int) float64 {
    res := 1.0
    // 贡献的初始值为 x
    x_contribute := x
    for n > 0 {
        if n % 2 == 1 {
            // 如果 N 二进制表示的最低位为 1，那么需要计入贡献
            res *= x_contribute
        }
        // 将贡献不断地平方
        x_contribute *= x_contribute
        n = n / 2
    }
    return res
}
```

---

## 



```go

```

---

## 



```go

```

---

## 



```go

```

---

## 



```go

```

---

## 



```go

```

---

## 



```go

```

---

## 



```go

```

---

## 



```go

```

---

## 



```go

```

---

## 



```go

```

---

## 



```go

```

---

## 



```go

```

---

## 



```go

```

---

## 



```go

```

---

## 



```go

```

---

## 



```go

```

---

## 



```go

```

---

## 



```go

```

---

