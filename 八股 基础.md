## 1. 抽奖系统设计

- 负载均衡层的限流
  **防止用户重复抽奖**；
  **开奖后暴力拦截流量**，抽奖服务一旦全部开奖完毕，直接更新一个共享状态。然后负载均衡感知到了之后，后续请求全部拦截掉返回一个抽奖结束的标识就可以了。

- 在抽奖服务和礼品服务之间，引入消息中间件，进行**限流削峰**。

  ![img](./assets/1be3a0b881ab375c14c993022936f8af.png)

## 2. go map实现

Go map 底层实现方式是 Hash 表。Go map 的数据被置入一个由桶组成的有序数组中，每个桶最多可以存放 8 个 key/value 对。**key 的 Hash 值低位用于在该数组中定位到桶，而高 8 位则用于在桶中区分 key/value 对。**

Go map 的 hash 表中的基本单位是桶，每个桶最多存 8 个键值对，超了则会链接到额外的溢出桶。所以 Go map 基本数据结构是**hash数组+桶内的key-value数组+溢出的桶链表**。

<img src="./assets/rafej6fyu0.png" alt="https://img2018.cnblogs.com/blog/1480383/201911/1480383-20191104215659319-1712154558.jpg" style="zoom: 50%;" />

当 Hash 表超过阈值需要扩容增长时，会分配一个新的桶数组，新数组的大小一般是旧数组的 2 倍。这里从旧数组将数据迁移到新数组，不会一次全量拷贝，因为耗时太大，Go 会在每次读写 Map 时以桶为单位做动态搬迁。



## 3. go gc

**追踪式 GC：从根对象（全局变量、执行栈，堆内存指针）出发**，根据对象之间的引用信息，一步步推进直到扫描完毕整个堆并确定需要保留的对象，从而回收所有可回收的对象。Go、 Java、V8 对 JavaScript 的实现等均为追踪式 GC。
**STW**：全称是stop the word，GC期间某个阶段会停止所有的赋值器，中断你的程序逻辑，以确定引用关系。
观察GC：设置**`GODEBUG=gctrace=1`**环境变量；**pprof**包查看CPU使用、内存分配以及协程的使用情况

**三色标记法**：（解决STW问题）

白色对象（可能死亡）：未被回收器访问到的对象。在回收开始阶段，所有对象均为白色，当回收结束后，白色对象均不可达。
灰色对象（波面）：已被回收器访问到的对象，但回收器需要对其中的一个或多个指针进行扫描，因为他们可能还指向白色对象。
黑色对象（确定存活）：已被回收器访问到的对象，其中所有字段都已被扫描，黑色对象中任何一个指针都不可能直接指向白色对象。

**当垃圾回收开始时，只有白色对象**。随着标记过程开始进行时，**灰色对象开始出现**（着色），这时候波面便开始扩大。当一个对象的所有子节点均完成扫描时，会被着色为**黑色**。当整个堆遍历完成时，**只剩下黑色和白色对象**，这时的黑色对象为可达对象，即存活；而白色对象为不可达对象，即死亡。这个过程可以视为以灰色对象为波面，将黑色对象和白色对象分离，使波面不断向前推进，直到所有可达的灰色对象都变为黑色对象为止的过程。

![三色标记法全貌](./assets/1713437200557RzlMu0.png)

在三色标记法的过程中对象丢失，需要同时满足下面两个条件：

条件一：白色对象被黑色对象引用
条件二：灰色对象与白色对象之间的可达关系遭到破坏

- **插入写屏障**

  规则：当一个对象引用另外一个对象时，将另外一个对象标记为灰色。

  满足：强三色不变式。不会存在黑色对象引用白色对象

这里需要注意一点，**插入屏障仅会在堆内存中生效，不对栈内存空间生效**，这是因为go在并发运行时，大部分的操作都发生在栈上，函数调用会非常频繁。数十万goroutine的栈都进行屏障保护自然会有性能问题。

插入写屏障最大的弊端就是，在一次正常的三色标记流程结束后，**需要对栈上重新进行一次stw，然后再rescan一次**。

- **删除写屏障**

  规则：在删除引用时，如果被删除引用的对象自身为灰色或者白色，那么被标记为灰色。

  满足：弱三色不变式。灰色对象到白色对象的路径不会断。

弊端：一个对象的引用被删除后，即使没有其他存活的对象引用它，它**仍然会活到下一轮**。

- **混合写屏障机制**

  GC刚开始的时候，会将栈上的可达对象全部标记为黑色。

  **GC期间，任何在栈上新创建的对象，均为黑色**。（避免了二次扫描）

  > 屏障限制只在堆内存中生效。避免了最后节点对栈进行STW的问题，提升了GC效率 

  **堆上被删除的对象标记为灰色**

  **堆上新添加的对象标记为灰色**



## 4. 内存逃逸原理 举例

内存逃逸（Memory Escape）是指变量的内存分配位置从栈上转移到堆上。

通过逃逸分析，可以尽量把那些不需要分配到堆上的变量直接分配到栈上，堆上的变量变少了，会减轻堆内存分配的开销，同时也会减少垃圾回收（Garbage Collction，GC）的压力，提高程序运行速度。

- 如果变量在函数外部没有被引用，则优先放到栈上。
- 如果变量在函数外部存在引用，则必定放在堆上。

```go
func  foo() *int {
    t :=  3
    return  &t
}

func  main() {
    x :=  foo()
    fmt.Println(*x)
}
// foo 函数里的变量 t 逃逸了，和预想的一致，不解的是为什么 main 函数里的 x 也逃逸了？这是因为有些函数的参数为 interface 类型，比如 fmt.Println(a ...interface{}) ，编译期间很难确定其参数的具体类型，也会发生逃逸。
```

- **减少指针使用**：尽量避免返回指向局部变量的指针。
- **限制变量作用域**：避免将其暴露给外部。
- **合理使用闭包**：尽量减少闭包捕获的局部变量数量。



## 5. 值传递

- Go里面没有`引用传递`，Go语言是`值传递`。
- 如果需要函数内部的修改能影响到函数外部，那么就传指针。
- `map/channel` 本身就是指针，是引用类型，所以直接传 `map和channel` 本身就可以。
- slice` 的赋值操作其实是针对 `slice` 结构体内部的指针进行操作，也是指针，可以直接传 `slice` 本身。` 
- `slice` 的 `append 操作` 同时需要修改结构体的 `len/cap`，类似于 `struct`，如果需要传递到函数外部，需要传指针。（或者使用函数返回值）



## 6. Goroutine | 协程

- **轻量级**：Goroutine 的栈空间初始大小只有 2KB，可以动态扩容，最大可达 1GB
- **快速启动**：Goroutine 的启动时间只有 1~2us
- **高效调度**：Goroutine 的调度器采用 M:N 模型，可以将 M 个 Goroutine 映射到 N 个 OS 线程上，实现高效调度
- **通信简单**：Goroutine 之间通过 Channel 进行通信，实现数据共享
- **无锁**：Goroutine 之间通过 Channel 进行通信，无需加锁
- **高并发**：Goroutine 可以轻松创建数十万个，实现高并发
- **高性能**：Goroutine 的调度器采用抢占式调度，实现高性能

进程、线程与协程的区别？

进程是操作系统分配资源和调度的基本单位。
线程是进程中的一个执行单元，线程共享进程的资源（如内存、文件描述符），但有独立的栈和寄存器。
协程是比线程更轻量级的并发单位，协程由程序员手动调度而非操作系统调度。**内核线程依然叫 “线程 (thread)”，用户线程叫 “协程 (co-routine)”。**

线程由 CPU 调度是抢占式的，**协程由用户态调度是协作式的，一个协程让出 CPU 后，才执行下一个协程**。



## 7. GMP 调度器

在 Go 中，线程是运行 goroutine 的实体，调度器的功能是把可运行的 goroutine 分配到工作线程上。

- **全局队列**：存放所有正在等待运行的 `G`
- **本地队列**：每个 `P` 都有一个本地队列， 用于存放当前 `P` 等待和正在运行的 `G`，每个 `P` 的本地队列中最多存放 `256` 个 `G` 。创建 `G` 时，会优先放入本地队列，如果本地队列满了， 则会将队列中一半的 `G` 移动到全局队列中。

- **P 的数量**：`P` 的数量是固定的，由 `GOMAXPROCS` 决定，即最大并发数, 默认为 `CPU` 核数。
- **M 的数量**：`M` 的数量是动态的，由调度器决定，根据当前的负载情况动态调整, GO默认设置为 10000，实际上内核很难达到该限制，可以认为是没有限制。`M` 想要运行任务就需要获取 `P`，如果没有 `P`，`M` 就会阻塞。如果 `P` 的本地队列为空，`M` 会从全局队列中获取 `G`，放入本地队列。 如果全局队列也为空，`M` 会从其他随机一个 `P` 的本地队列中获取一半的 `G` 放到本地队列中。

<img src="./assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3htY3kwMDExMjI=,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述" style="zoom:67%;" />

- 调度器策略

  | 策略       | 描述                                                         |
  | ---------- | ------------------------------------------------------------ |
  | 抢占式调度 | 在协程中需要一个协程主动让出 CPU 下一个协程才能使用 CPU， 而 Goroutine 规定一个 Goroutine 每次**最多只能占用 10ms 的 CPU**，然后就要切换到下一个, 防止其他协程长时间不被执行 |
  | 复用线程   | 调度器会复用线程，而不是每次都创建新的线程，这样可以减少线程创建和销毁的开销，提高性能。 - **工作偷取(Work stealing)**:当 `M` 没有可运行的 `G` 时，会尝试从其他线程绑定的 `P` 的本地队列中偷取一半的 `G`来运行，而不是销毁 `M` - **挂起机制(Hand off)**: 当 `G` 由于系统调用而阻塞时, `M` 会释放绑定的 `P` 供其他 `M` 使用 |
  | 并行       | 通过 `GOMAXPROCS` 配置 `P` 的数量，从而实现并行执行，`P` 的数量决定了并行度，`P` 的数量等于 CPU 核数时，可以实现最大并行度。 |
  | 全局队列   | 当本地队列中没有可运行的 `G`， `M` 会先去全局队列尝试获取 `G`， 若全局队列中没有待运行的 `G` 则会尝试去其他 `P` 的本地队列中偷取 `G` |



## 8. 计网基础

### 8. 1 TCP和IP模型

| OSI七层模型 | TCP/IP 五层模型 | TCP/IP 四层模型 | 功能                                     | TCP/IP协议族                             |
| ----------- | --------------- | --------------- | ---------------------------------------- | ---------------------------------------- |
| 应用层      | 应用层          | 应用层          | 文件传输，电子邮件，文件服务，虚拟终端等 | SMTP，DNS，Telnet，TFTP，HTTP，SNHP，FTP |
| 表示层      | 应用层          | 应用层          | 数据格式化，代码转换，数据加密           | 无                                       |
| 会话层      | 应用层          | 应用层          | 解除或建立与别的接点的联系               | 无                                       |
| 传输层      | 传输层          | 传输层          | 提供端对端的接口                         | TCP，UDP                                 |
| 网络层      | 网络层          | 网络层          | 为数据包选择路由                         | IP，ICHP，RIP，OSPF，BCP，ICMF           |
| 数据链路层  | 数据链路层      | 网络接口层      | 传输有地址的顿以及错误检测功能           | SLIP，CSLIP，PPP，ARP，RARP，MTU         |
| 物理层      | 物理层          | 网络接口层      | 以二进制数据形式在物理媒介上传输数据     | IS02110，IEEE802，IEEE802.2              |



### 8. 2 HTTP 1.0 vs 1.1 vs 2.0

| 特性     | HTTP 1.0                                             | HTTP 1.1                                                     | HTTP 2.0                                                     |
| -------- | ---------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 连接方式 | 无连接，每次请求都要建立连接                         | **长连接**，减少了 TCP 连接的重复建立和断开所造成的额外开销  | **多路复用**，一个 TCP 连接上可以并发多个 HTTP 请求          |
| 队头阻塞 | 存在，下一个请求必须在前一个请求响应到达之前才能发送 | 存在，虽然可以发起多个请求，但服务器必须按照接收请求的顺序发送响应 | 解决，可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应 |



### 8. 3 HTTP 状态码

| 数字 | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| 1XX  | 指示信息，表示请求以接收，继续处理                           |
| 2XX  | 成功，表示请求已经被成功接收、理解、接受                     |
| 3XX  | 状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向 |
| 4XX  | 状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。 |
| 5XX  | 状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码 |



### 8. 4 HTTP HTTPS

HTTP协议运⾏在TCP之上，所有传输的内容都是明⽂，客户端和服务器端都⽆法验证对⽅的⾝份。
HTTPS是运⾏在SSL/TLS之上的HTTP协议，SSL/TLS 运⾏在TCP之上。所有传输的内容都经过加密，加密采⽤对
称加密(DES AES)，但对称加密的密钥⽤服务器⽅的证书进⾏了⾮对称加密（RSA DSA）。





## 9. 打开https://www.baidu.com的过程

- **DNS 解析**：当用户输入一个网址并按下回车键的时候，浏览器获得一个域名，而在实际通信过程中，我们需要的是一个 IP 地址，因此我们需要先把域名转换成相应 IP 地址。
- **TCP 连接**：浏览器通过 DNS 获取到 Web 服务器真正的 IP 地址后，便向 Web 服务器发起 TCP 连接请求，通过 TCP 三次握手建立好连接。
- 建立TCP协议时，需要发送数据，发送数据**在网络层使用IP协议， 通过IP协议将IP地址封装为IP数据报**；然后此时会用到**ARP协议**，主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此**确定目标的物理地址，找到目的MAC地址**；
- IP数据包在路由器之间，**路由选择使用OPSF(开放式最短路径优先)协议**， 采用Dijkstra算法来计算最短路径树，抵达服务端。
- **发送 HTTP 请求**：建立 TCP 连接之后，浏览器向 Web 服务器发起一个 HTTP 请求（如果是HTTPS协议，发送HTTP 请求之前还需要完成**TLS四次握手**）；
- **处理请求并返回**：服务器获取到客户端的 HTTP 请求后，会根据 HTTP 请求中的内容来决定如何获取相应的文件，并将文件发送给浏览器。
- **浏览器渲染**：浏览器根据响应开始显示页面，首先解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。

## 10. TCP 三次握手 四次挥手

<img src="./assets/tcp-connect.png" alt="TCP Connection" style="zoom: 50%;" />

### 10.1 三次握手

1. 客户端发送`SYN=1`，并指明客户端的初始序列号`ISN`，即`x`.
2. 服务端发送自己的`SYN`段作为应答，同样指明自己的`ISN` 即 `y`。为了确认客户端的`SYN`，将`x+1`作为`ACK`数值。这样，每发送一个`SYN`，序列号就会加1. 如果有丢失的情况，则会重传。
3. 为了确认服务器端的`SYN`，客户端将`y+1`作为返回的`ACK`数值。

> **TCP 建立连接的过程就是同步序列号的过程，SYN (Synchronize Sequence Numbers)就是同步序列号。因此，三次握手的目的就是使客户端(Client)和服务端(Service)获取到对方的序列号。**

### 10.2 四次挥手

（1）客户端发送⼀个FIN
⽤来关闭客户端到服务器的数据传送，此后客户端进⼊FIN_WAIT_1状态。
（2）服务器收到FIN后
进⼊CLOSE_WAIT状态。正常情况下会发送⼀个ACK给客户端，确认序号为收到序号+1（与SYN相同，⼀个FIN占
⽤⼀个序号）。
（3）服务器发送⼀个FIN
⽤来关闭服务器到客户端的数据传送，服务器进⼊LAST_ACK状态。
（4）客户端收到FIN后
客户端进⼊TIME_WAIT状态，接着发送⼀个ACK给服务器，确认序号为收到序号+1，服务器进⼊CLOSED状态，
完成四次挥⼿。

> **之所以需要四次挥手，是因为 tcp 是全双工协议，即客户端和服务端都可以主动发送消息，因此需要两端分别在传输完成后发送断开连接的指令，需要分别发送 `FIN=1` 指令断开，通过 `ACK` 判断是否发送成功。**

### 10.3 超时重传

在快速重传机制下，在数据包丢失后，接收端每接收一个失序的数据包就立即返回重复的确认报文段，告知发送端缺少的报文段。当发送方**收到三个重复的确认报文段**后，会立即重传缺失的报文段。

### 10.4 流量控制 点到点

TCP 使用滑动窗口来控制流量，使得发送端可以根据接收端的接收能力控制发送数据的速度。

### 10.5 拥塞控制

###### [**快重传和快恢复**](https://goguide.ryansu.tech/guide/concepts/network/3-tcp-udp.html#快重传和快恢复)

快重传在前面已介绍过，即如果连续收到三个重复的确认就会立即发送尚未接收到的报文段。快恢复算法需要配合快重传算法使用。

快恢复算法：

- 当发送端连续收到三个重复的确认时，将 `ssthresh` 减半。
- 将 `cwnd` (拥塞窗口)设置为 `ssthresh` (慢开始门限)的大小



## 11. UDP

> 无连接、速度快、不可靠性、应用广泛

| 特性/指标              | TCP（Transmission Control Protocol）                         | UDP（User Datagram Protocol）                                |
| ---------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **连接方式**           | 面向连接，需建立连接（三次握手）                             | 无连接，直接发送数据包                                       |
| **可靠性**             | 提供可靠的传输服务，确保数据包按顺序到达，不丢失、不重复     | 不可靠传输，不保证数据包的可靠性和顺序性                     |
| **流控制**             | 有流控制，通过滑动窗口机制控制发送速率                       | 无流控制，发送方可以快速发送数据                             |
| **拥塞控制**           | 有拥塞控制，通过算法调整发送速率，避免网络拥塞               | 无拥塞控制，不对网络状况进行调整                             |
| **传输开销**           | 较高，需建立和维护连接                                       | 低，无需建立和维护连接                                       |
| **传输延迟**           | 较高，由于可靠性和流控机制                                   | 低，由于没有可靠性和流控机制                                 |
| **适用场景**           | 文件传输（FTP、SFTP）、电子邮件（SMTP）、网页浏览（HTTP/HTTPS）、数据库连接（如 MySQL、PostgreSQL） | 实时应用（音视频流、VoIP、在线游戏）、广播和组播（实时更新、状态信息广播）、简单的查询响应协议（如 DNS） |
| **实例比较：视频会议** | 不太适合，重传机制会导致延迟增加，影响实时性                 | 适合，需要低延迟，即使偶尔丢失一些数据包也不影响太大         |
| **实例比较：文件传输** | 适合，需要确保数据的完整性和顺序性，避免文件损坏             | 不适合，不保证数据的可靠性和顺序性，容易导致文件损坏         |



## 12. B树

MySQL数据库索引采⽤的是B+Tree结构，在B-Tree结构上做了优化改造。

- B-Tree结构

1. 索引值和data数据**分布在整棵树**结构中

2. 每个节点可以存放多个索引值及对应的data数据

3. 树节点中的多个索引值从左到右升序排列


- B+Tree结构：

1. ⾮叶⼦节点不存储data数据，只存储索引值，这样便于存储更多的索引值
2. **叶⼦节点包含了所有的索引值和data数据**
3. 叶⼦节点⽤**指针连接**，提⾼区间的访问性能

mysql索引：从存储结构分：分成B+索引，hash索引
InnoDB 只⽀持显式创建 B+Tree 索引，对于⼀些热点数据页，InnoDB 会⾃动建⽴⾃适应 Hash 索引，也就是在 B+Tree 索引基础上建⽴ Hash 索引， 这个过程对于客户端是不可控制的，隐式的。



## 13. SQL事务

### 13.1 MySQL 保证一致性？

> 数据库通过原⼦性、隔离性、持久性来保证⼀致性。

- Mysql 怎么保证原⼦性的？（undo log）

  利⽤Innodb的 **undo log** 。undo log 名为回滚⽇志，是实现原⼦性的关键，当事务回滚时能够**撤销所有已经成功执⾏的sql语句**，他需要记录你要回滚的相应⽇志信息。
  例如：
  当你 delete ⼀条数据的时候，就需要记录这条数据的信息，回滚的时候，insert 这条旧数据;
  当你 update ⼀条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执⾏ update 操作;
  当你 insert ⼀条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执⾏ delete 操作.
  undo log 记录了这些回滚需要的信息，当事务执⾏失败或调⽤了 rollback，导致事务需要回滚，便可以利⽤undo
  log 中的信息将数据回滚到修改之前的样⼦。

- Mysql 怎么保证持久性的？(redo log)
  利⽤ Innodb 的 redo log。Mysql是先把磁盘上的数据加载到内存中，在内存中对数据进⾏修改，再刷回磁盘上。如果此时突然宕机，内存中的数据就会丢失。

  **WAL（Write-Ahead Logging）技术**：MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上。**在事务提交时，只要先将 redo log 持久化到磁盘即可**，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。redo log 是物理日志，记录了某个数据页做了什么修改，比如**对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新**。

  - 为什么需要 redo log ？

  - **实现事务的持久性，让 MySQL 有 crash-safe 的能力**，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；
  - **将写操作从「随机写」变成了「顺序写」**，提升 MySQL 写入磁盘的性能。



### 13.2 隔离级别

| 术语                     | 定义                                                         |
| ------------------------ | ------------------------------------------------------------ |
| **脏读**(读未提交级别)   | 脏读指的是读到了**其他事务未提交的数据**，未提交意味着这些数据可能会回滚，也就是不存在的数据。 |
| **不可重复读**(读已提交) | 对比可重复读，不可重复读指的是**在同一事务内，不同的时刻读到的同一批数据可能是不一样的**，可能会受到其他事务的影响，比如其他事务改了这批数据并**提交了**。不可重复读常在数据更新时出现。 |
| **幻读**(可重复读)       | 在一个事务中明明没有查到主键为 X 的数据，但主键为 X 的数据就是插入不进去 |

> 数据库的默认隔离级别是 `REPEATABLE-READ`（可重复读），这不能避免幻读
>
> 在 MySQL 中，主要通过 **MVCC**（多版本并发控制）来实现隔离级别，MVCC 是通过保存数据在某个时间点的快照来实现的，这样可以保证事务在执行过程中看到的数据是一致的。

- 不可重复读和脏读的区别：脏读可以读到其他事务中未提交的数据，而不可重复读是读取到了其他事务已经提交的数据，但前后两次读取的结果不同。

- 不可重复读和幻读的区别：二者描述的侧重点不同，不可重复读描述的侧重点是修改操作，而幻读描述的侧重点是添加和删除操作。

---

### 13.3 MVCC

引⼊mvcc 后，只有写写操作是阻塞的，mysql的实现原理是在数据节点有两个字段列，trid，rollbackpointer。
**在修改操作时，会加上⾏级锁，但上锁的开销较⼤**，MVCC就是为了解决开销问题⽽存在，**很多情况下可以代替⾏级锁。**
实现原理是因为每个事务进⾏修改操作时，都会往 undo.log 中写⼊内容，⽽历史版本可以通过前⾯的 trid 和
rollbackpointer 寻找到快照信息，具体读取哪个快照按隔离级别计算。



## 14. Redis

> Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此**读写速度非常快**，常用于**缓存，消息队列、分布式锁等场景**。

### 14.1 为什么用 Redis 作为 MySQL 的缓存？

主要是因为 **Redis 具备「高性能」和「高并发」两种特性**。
高性能：直接操作内存；高并发：单机QPS是mysql的十倍（10w+）

### 14.2 五种常见的 Redis 数据类型是怎么实现？

<img src="./assets/9fa26a74965efbf0f56b707a03bb9b7f.png" alt="img" style="zoom:50%;" />

> String 类型内部实现

String 类型的底层的数据结构实现主要是 SDS（简单动态字符串）。 SDS 和我们认识的 C 字符串不太一样，之所以没有使用 C 语言的字符串表示，因为 SDS 相比于 C 的原生字符串：

- **SDS 不仅可以保存文本数据，还可以保存二进制数据**。因为 SDS 使用 len 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 buf[] 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。
- **SDS 获取字符串长度的时间复杂度是 O(1)**。因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 len 属性记录了字符串长度，所以复杂度为 O(1)。
- **Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出**。因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。

> List 类型内部实现

List 类型的底层数据结构是由**双向链表或压缩列表**实现的：

- 如果列表的元素个数小于 512 个（默认值，可由 list-max-ziplist-entries 配置），列表每个元素的值都小于 64 字节（默认值，可由 list-max-ziplist-value 配置），Redis 会使用**压缩列表**作为 List 类型的底层数据结构；
- 如果列表的元素不满足上面的条件，Redis 会使用**双向链表**作为 List 类型的底层数据结构；

但是**在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表**。

> Hash 类型内部实现

Hash 类型的底层数据结构是由**压缩列表或哈希表**实现的：

- 如果哈希类型元素个数小于 512 个（默认值，可由 hash-max-ziplist-entries 配置），所有值小于 64 字节（默认值，可由 hash-max-ziplist-value 配置）的话，Redis 会使用**压缩列表**作为 Hash 类型的底层数据结构；
- 如果哈希类型元素不满足上面条件，Redis 会使用**哈希表**作为 Hash 类型的底层数据结构。

**在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了**。

> Set 类型内部实现

Set 类型的底层数据结构是由**哈希表或整数集合**实现的：

- 如果集合中的元素都是整数且元素个数小于 512 （默认值，set-maxintset-entries配置）个，Redis 会使用**整数集合**作为 Set 类型的底层数据结构；
- 如果集合中的元素不满足上面条件，则 Redis 使用**哈希表**作为 Set 类型的底层数据结构。

> ZSet 类型内部实现

Zset 类型的底层数据结构是由**压缩列表或跳表**实现的：

- 如果有序集合的元素个数小于 128 个，并且每个元素的值小于 64 字节时，Redis 会使用**压缩列表**作为 Zset 类型的底层数据结构；
- 如果有序集合的元素不满足上面的条件，Redis 会使用**跳表**作为 Zset 类型的底层数据结构；

**在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。**

---

### 14.3 如何避免缓存雪崩、缓存击穿、缓存穿透？

> 如何避免缓存雪崩？

<img src="./assets/e2b8d2eb5536aa71664772457792ec40.png" alt="img" style="zoom:50%;" />

**当大量缓存数据在同一时间过期（失效）时，如果此时有大量的用户请求**，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是缓存雪崩的问题。

对于缓存雪崩问题，我们可以采用两种方案解决。

- **将缓存失效时间随机打散：** 我们可以在原有的失效时间基础上增加一个随机值（比如 1 到 10 分钟）这样每个缓存的过期时间都不重复了，也就降低了缓存集体失效的概率。
- **设置缓存不过期：** 我们可以通过后台服务来更新缓存数据，从而避免因为缓存失效造成的缓存雪崩，也可以在一定程度上避免缓存并发问题。

> 如何避免缓存击穿？

如果缓存中的**某个热点数据过期**了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是**缓存击穿**的问题。

<img src="./assets/acb5f4e7ef24a524a53c39eb016f63d4.png" alt="img" style="zoom: 50%;" />

可以发现缓存击穿跟缓存雪崩很相似，可以认为缓存击穿是缓存雪崩的一个子集。 应对缓存击穿可以采取前面说到两种方案：

- **互斥锁方案**（Redis 中使用 **setNX** 方法设置一个状态位，表示这是一种锁定状态），保证同一时间只有一个业务线程请求缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。
- **不给热点数据设置过期时间**，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间；

> 如何避免缓存穿透？

**用户访问的数据，既不在缓存中，也不在数据库中**，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是**缓存穿透**的问题。

<img src="./assets/b7031182f770a7a5b3c82eaf749f53b0.png" alt="img" style="zoom:50%;" />

缓存穿透的发生一般有这两种情况：

- **业务误操作**，缓存中的数据和数据库中的数据都被误删除了，所以导致缓存和数据库中都没有数据；
- 黑客恶意攻击，故意大量访问某些读取不存在数据的业务；

应对缓存穿透的方案，常见的方案有三种。

- **非法请求的限制**：当有大量恶意请求访问不存在的数据的时候，也会发生缓存穿透，因此在 API 入口处我们要判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。
- **设置空值或者默认值**：当我们线上业务发现缓存穿透的现象时，可以针对查询的数据，在缓存中设置一个空值或者默认值，这样**后续请求就可以从缓存中读取到空值或者默认值**，返回给应用，而不会继续查询数据库。
- **使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在**：我们可以在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，业务线程确认缓存失效后，可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在，即使发生了缓存穿透，大量请求只会查询 Redis 和布隆过滤器，而不会查询数据库，保证了数据库能正常运行，Redis 自身也是支持布隆过滤器的。

### 14.4 缓存更新策略

常见的缓存更新策略共有3种：

- Cache Aside（旁路缓存）策略；
- Read/Write Through（读穿 / 写穿）策略；
- Write Back（写回）策略；

实际开发中，Redis 和 MySQL 的更新策略用的是 Cache Aside，另外两种策略应用不了。

> Cache Aside（旁路缓存）策略

**Cache Aside（旁路缓存）**策略是最常用的，应用程序直接与「数据库、缓存」交互，并负责对缓存的维护，该策略又可以细分为「读策略」和「写策略」。

<img src="./assets/6e3db3ba2f829ddc14237f5c7c00e7ce-20230309232338149.png" alt="img" style="zoom:50%;" />

**写策略的步骤：**

- **先更新数据库中的数据，再删除缓存中的数据。**

**读策略的步骤：**

- 如果读取的数据命中了缓存，则直接返回数据；
- **如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存**，并且返回给用户。

注意，写策略的步骤的顺序不能倒过来，即**不能先删除缓存再更新数据库**，原因是在「读+写」并发的时候，会出现缓存和数据库的数据不一致性的问题。

<img src="./assets/cc208c2931b4e889d1a58cb655537767-20230309232342573.png" alt="img" style="zoom:50%;" />

**为什么「先更新数据库再删除缓存」不会有数据不一致的问题？**

先更新数据库，再删除缓存也是会出现数据不一致性的问题，**但是在实际中，这个问题出现的概率并不高**。

**因为缓存的写入通常要远远快于数据库的写入**，所以在实际中很难出现请求 B 已经更新了数据库并且删除了缓存，请求 A 才更新完缓存的情况。而一旦请求 A 早于请求 B 删除缓存之前更新了缓存，那么接下来的请求就会因为缓存不命中而从数据库中重新读取数据，所以不会出现这种不一致的情况。

<img src="./assets/1cc7401143e79383ead96582ac11b615-20230309232407419.png" alt="img" style="zoom:50%;" />

**Cache Aside 策略适合读多写少的场景，不适合写多的场景**，因为当写入比较频繁时，缓存中的数据会被频繁地清理，这样会对缓存的命中率有一些影响。如果业务对缓存命中率有严格的要求，那么可以考虑两种解决方案：

- 一种做法是在更新数据时也更新缓存，只是在**更新缓存前先加一个分布式锁**，因为这样在同一时间只允许一个线程更新缓存，就不会产生并发问题了。当然这么做对于写入的性能会有一些影响；
- 另一种做法同样也是在更新数据时更新缓存，只是**给缓存加一个较短的过期时间**，这样即使出现缓存不一致的情况，缓存的数据也会很快过期，对业务的影响也是可以接受。

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

## 

