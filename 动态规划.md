## 爬楼梯

> 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
>
> - 输入： 3
> - 输出： 3
> - 解释： 有三种方法可以爬到楼顶。
>   - 1 阶 + 1 阶 + 1 阶
>   - 1 阶 + 2 阶
>   - 2 阶 + 1 阶

重要的是思想。类似斐波那契数列，比递归的时间复杂度会好很多。因为只需要前两个状态值，改进一下可以优化空间复杂度。

```go
func climbStairs(n int) int {
    if n <= 2 {
        return n
    }
    // dp[i] 为第 i 阶楼梯有多少种方法爬到楼顶
    // dp[i] = dp[i-1] + dp[i-2]
    dp := make([]int, n+1)
    dp[1], dp[2] = 1, 2
    for i := 3; i <= n; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }
    return dp[n]
}
```

---

## 不同路径

> 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？
>
> <img src="assets/1697422740-adxmsI-image.png" alt="img" style="float: left;" />
>
> - 输入：m = 3, n = 7
> - 输出：28

很能代表 dp 的一道题，递推会超时

```go
func uniquePaths(m int, n int) int {
	dp := make([][]int, m)
	for i := range dp {
		dp[i] = make([]int, n)
		dp[i][0] = 1
	}
	for j := 0; j < n; j++ {	// 到达第一行和第一列的任何地方都只存在一条路径
		dp[0][j] = 1
	}
	for i := 1; i < m; i++ {
		for j := 1; j < n; j++ {
			dp[i][j] = dp[i-1][j] + dp[i][j-1]
		}
	}
	return dp[m-1][n-1]
}
```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

## 

> 



```go

```

---

