## 移除链表元素

> 删除链表中等于给定值 val 的所有节点。
>
> 示例 1： 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5]
>
> 示例 2： 输入：head = [], val = 1 输出：[]
>
> 示例 3： 输入：head = [7,7,7,7], val = 7 输出：[]

在单链表中移除头结点 和 移除其他节点的操作方式是不一样，其实在写代码的时候也会发现，需要单独写一段逻辑来处理移除头结点的情况。那么可不可以 以一种统一的逻辑来移除 链表的节点呢。其实**可以设置一个虚拟头结点**，这样原链表的所有节点就都可以按照统一的方式进行移除了。

<img src="assets/20210316095619221.png" alt="203_链表删除元素6" style="zoom: 50%;" />

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func removeElements(head *ListNode, val int) *ListNode {
	dummyHead := &ListNode{}	
    //当声明一个指针变量时，它的默认值是 nil，表示指针不指向任何有效的内存地址。因此，在给 dummyHead 分配内存之前，你需要先为其分配一个实际的节点。
	dummyHead.Next = head

	current := dummyHead
	for current.Next != nil {
		if current.Next.Val == val {
			current.Next = current.Next.Next
		} else {
			current = current.Next
		}
	}

	return dummyHead.Next
}
```

---

## 设计链表

> 在链表类中实现这些功能：
>
> - get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。
> - addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。
> - addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。
> - addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。
> - deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。

`addAtHead(val）`、`addAtTail(val) `都可以调用 `addAtIndex(index,val)`

```go
type MyLinkedList struct {
	dummyHead *ListNode
	size      int
}

func Constructor() MyLinkedList {
	newNode := &ListNode{}
	return MyLinkedList{ // 返回链表
		dummyHead: newNode,
		size:      0,
	}
}

func (this *MyLinkedList) Get(index int) int {
	if this == nil || index < 0 || index >= this.size {
		return -1
	}
	cur := this.dummyHead.Next
	for index > 0 {
		cur = cur.Next
		index -= 1
	}
	return cur.Val
}

func (this *MyLinkedList) AddAtHead(val int) {
	this.AddAtIndex(0, val)
}

func (this *MyLinkedList) AddAtTail(val int) {
	this.AddAtIndex(this.size, val)
}

func (this *MyLinkedList) AddAtIndex(index int, val int) {
	if index > this.size {
		return
	}
	cur := this.dummyHead
	for index > 0 {
		cur = cur.Next
		index -= 1
	}
	newNode := &ListNode{Val: val}
	newNode.Next = cur.Next
	cur.Next = newNode
	this.size += 1

}

func (this *MyLinkedList) DeleteAtIndex(index int) {
	if index < 0 || index > this.size-1 {
		return
	}
	cur := this.dummyHead
	for index > 0 {
		cur = cur.Next
		index -= 1
	}
	if cur.Next != nil {
		cur.Next = cur.Next.Next
	}
	this.size -= 1
}
```

---

## 反转链表

> 反转一个单链表。
>
> 示例: 输入: 1->2->3->4->5->NULL 输出: 5->4->3->2->1->NULL

<img src="assets/20210218090901207.png" alt="206_反转链表" style="zoom:50%;float:left" />

注意：不要使用 `prev := &ListNode{}` 初始化prev，将 `prev` 的初始值设置为 `nil`，而不是一个空的 `ListNode`

```go
//双指针
func reverseList(head *ListNode) *ListNode {
	var prev *ListNode	//notice!

	for head != nil {
		temp := head.Next
		head.Next = prev
		prev = head
		head = temp
	}
	return prev
}

//递归
func reverseList(head *ListNode) *ListNode {
    return help(nil, head)
}

func help(pre, head *ListNode)*ListNode{
    if head == nil {
        return pre
    }
    next := head.Next
    head.Next = pre
    return help(head, next)
}
```

---

## 两两交换链表中的节点

> 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
>
> <img src="assets/swap_ex1.jpg" alt="img" style="float: left;" />

